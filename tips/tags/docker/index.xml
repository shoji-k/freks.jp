<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>freks tips</title>
    <link>https://freks.jp/tips/tags/docker/index.xml</link>
    <description>Recent content on freks tips</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <atom:link href="https://freks.jp/tips/tags/docker/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>amazon ecs</title>
      <link>https://freks.jp/tips/amazon-ecs/</link>
      <pubDate>Fri, 10 Mar 2017 14:29:18 +0900</pubDate>
      
      <guid>https://freks.jp/tips/amazon-ecs/</guid>
      <description>

&lt;p&gt;see &lt;a href=&#34;http://docs.aws.amazon.com/ja_jp/AmazonECS/latest/developerguide/Welcome.html&#34;&gt;Amazon EC2 Container Service とは&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;クラスター&#34;&gt;クラスター&lt;/h1&gt;

&lt;p&gt;一番大枠&lt;br /&gt;
中に立ち上げるEC2インスタンスの数を決められる&lt;/p&gt;

&lt;h1 id=&#34;コンテナインスタンス&#34;&gt;コンテナインスタンス&lt;/h1&gt;

&lt;p&gt;EC2インスタンス&lt;br /&gt;
dockerとecs agent入りの&lt;a href=&#34;http://docs.aws.amazon.com/ja_jp/AmazonECS/latest/developerguide/ecs-optimized_AMI.html?shortFooter=true&#34;&gt;AMI&lt;/a&gt;を使う&lt;/p&gt;

&lt;p&gt;EC2を自分で用意してクラスターに参加させることもできる&lt;/p&gt;

&lt;h1 id=&#34;タスク定義&#34;&gt;タスク定義&lt;/h1&gt;

&lt;p&gt;Docker imageの指定&lt;br /&gt;
CPU、メモリの指定&lt;/p&gt;

&lt;p&gt;複数のコンテナを指定できる&lt;/p&gt;

&lt;p&gt;&lt;blockquote&gt;
同じインスタンスでどのプロセスを一緒に実行する必要があるか、各コンポーネントをどのようにスケーリングするかを検討します
&lt;/blockquote&gt;
&lt;small&gt;&lt;a href=&#34;http://docs.aws.amazon.com/ja_jp/AmazonECS/latest/developerguide/application_architecture.html&#34;&gt;http://docs.aws.amazon.com/ja_jp/AmazonECS/latest/developerguide/application_architecture.html&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;

&lt;h1 id=&#34;サービス&#34;&gt;サービス&lt;/h1&gt;

&lt;p&gt;&lt;blockquote&gt;
タスク定義の指定した数 (&amp;ldquo;必要数&amp;rdquo;) のインスタンスを ECS クラスターで同時に実行して維持できます。
&lt;/blockquote&gt;
&lt;small&gt;
&lt;a href=&#34;http://docs.aws.amazon.com/ja_jp/AmazonECS/latest/developerguide/ecs_services.html?shortFooter=true&#34;&gt;http://docs.aws.amazon.com/ja_jp/AmazonECS/latest/developerguide/ecs_services.html?shortFooter=true&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;タスクが停止したらタスクを強制終了、再度開始する&lt;/li&gt;
&lt;li&gt;ロードバランサーの指定&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;composeを使う&#34;&gt;composeを使う&lt;/h1&gt;

&lt;p&gt;ecs-cli をインストールして使う&lt;/p&gt;

&lt;p&gt;see [&lt;a href=&#34;https://docs.aws.amazon.com/ja_jp/AmazonECS/latest/developerguide/ECS_CLI_tutorial.html&#34;&gt;https://docs.aws.amazon.com/ja_jp/AmazonECS/latest/developerguide/ECS_CLI_tutorial.html&lt;/a&gt;]&lt;/p&gt;

&lt;p&gt;ecs-cliの設定&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ecs-cli configure --region us-west-2 --access-key $AWS_ACCESS_KEY_ID --secret-key $AWS_SECRET_ACCESS_KEY --cluster ecs-cli-demo
INFO[0000] Saved ECS CLI configuration for cluster (ecs-cli-demo)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;２つインスタンスを作る&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ecs-cli up --keypair id_rsa --capability-iam --size 2 --instance-type t2.medium
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;keypairは指定したリージョン内のEC2のキーペアを指定する&lt;br /&gt;
権限がいくつか必要、IAM:USER:ROLEとECS&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>docker machine</title>
      <link>https://freks.jp/tips/docker-machine/</link>
      <pubDate>Wed, 22 Feb 2017 12:01:25 +0900</pubDate>
      
      <guid>https://freks.jp/tips/docker-machine/</guid>
      <description>

&lt;h1 id=&#34;install&#34;&gt;install&lt;/h1&gt;

&lt;p&gt;see &lt;a href=&#34;https://docs.docker.com/machine/install-machine/&#34;&gt;Install Docker Machine - Docker&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;commands&#34;&gt;commands&lt;/h1&gt;

&lt;p&gt;managerのホスト名のvirtual machineを用意&lt;br /&gt;
$ docker-machine create &amp;ndash;driver virtualbox manager&lt;/p&gt;

&lt;p&gt;virtual machine一覧&lt;br /&gt;
active * はシェルがつながっているもの&lt;/p&gt;

&lt;p&gt;$ docker-machine ls&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NAME      ACTIVE   DRIVER       STATE     URL                         SWARM   DOCKER    ERRORS
manager   *        virtualbox   Running   tcp://192.168.99.100:2376           v1.13.1   
worker    -        virtualbox   Running   tcp://192.168.99.101:2376           v1.13.1  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;IPを表示&lt;br /&gt;
$ docker-machine ip manager&lt;/p&gt;

&lt;p&gt;環境変数を表示&lt;br /&gt;
$ docker-machine env manager&lt;/p&gt;

&lt;p&gt;手元のシェルとvirutal machineのシェルをつなぐ&lt;br /&gt;
$ eval $(docker-machine env manager)&lt;/p&gt;

&lt;p&gt;managerへsshログイン&lt;br /&gt;
$ docker-machine ssh manager&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                        ##         .
                  ## ## ##        ==
               ## ## ## ## ##    ===
           /&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;\___/ ===
      ~~~ {~~ ~~~~ ~~~ ~~~~ ~~~ ~ /  ===- ~~~
           \______ o           __/
             \    \         __/
              \____\_______/
 _                 _   ____     _            _
| |__   ___   ___ | |_|___ \ __| | ___   ___| | _____ _ __
| &#39;_ \ / _ \ / _ \| __| __) / _` |/ _ \ / __| |/ / _ \ &#39;__|
| |_) | (_) | (_) | |_ / __/ (_| | (_) | (__|   &amp;lt;  __/ |
|_.__/ \___/ \___/ \__|_____\__,_|\___/ \___|_|\_\___|_|
Boot2Docker version 1.13.1, build HEAD : b7f6033 - Wed Feb  8 20:31:48 UTC 2017
Docker version 1.13.1, build 092cba3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;initialize swarm&lt;br /&gt;
docker@manager:~$ docker swarm init &amp;ndash;advertise-addr 192.168.99.100&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Swarm initialized: current node (vr7gm59os0kbgeou8oickuv3y) is now a manager.

To add a worker to this swarm, run the following command:

    docker swarm join \
    --token SWMTKN-1-69gbc5d50la1ta5mtk67lrno5phgoqq4ebaztnf4h91dj6era3-71p3dn14eu6zhumv0p254r3xy \
    192.168.99.100:2377
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;workerにsshログイン、swarn init後のコマンドを実行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker@worker:~$  docker swarm join \
&amp;gt;     --token SWMTKN-1-69gbc5d50la1ta5mtk67lrno5phgoqq4ebaztnf4h91dj6era3-71p3dn14eu6zhumv0p254r3xy \
&amp;gt;     192.168.99.100:2377
This node joined a swarm as a worker.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;nodeを表示&lt;/p&gt;

&lt;p&gt;docker@manager:~$ docker node ls&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ID                           HOSTNAME  STATUS  AVAILABILITY  MANAGER STATUS
vr7gm59os0kbgeou8oickuv3y *  manager   Ready   Active        Leader
y2y9i98fd78f5qzvi3o5kuj18    worker    Ready   Active  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;prepare docker-stack.yml and deploy&lt;/p&gt;

&lt;p&gt;docker@manager:~$ docker stack deploy &amp;ndash;compose-file docker-stack.yml vote&lt;/p&gt;

&lt;p&gt;確認する&lt;br /&gt;
docker@manager:~$ docker stack services vote&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>docker compose</title>
      <link>https://freks.jp/tips/docker-compose/</link>
      <pubDate>Thu, 24 Nov 2016 18:30:59 +0900</pubDate>
      
      <guid>https://freks.jp/tips/docker-compose/</guid>
      <description>

&lt;h1 id=&#34;install&#34;&gt;install&lt;/h1&gt;

&lt;p&gt;reffer to:&lt;br /&gt;
&lt;a href=&#34;https://docs.docker.com/compose/install/&#34;&gt;Install Compose&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;docker-compose-yml&#34;&gt;docker-compose.yml&lt;/h1&gt;

&lt;p&gt;assign image&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;image: httpd:lastst  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;assign image built by Dockerfile&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;build: .  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;set command (use bash)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;command: /bin/bash  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;write container to hosts file&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;links:
- dbserver  
- dbserver:mysql  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;hosts file is written&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;192.168.100.10 dbserver
192.168.100.10 mysql
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;write container not in same docker-compose.yml to hosts file&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;external_links:
- dbserver  
- dbserver:mysql  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;set open port&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ports:
- &amp;quot;3000&amp;quot;  
- &amp;quot;8080:80&amp;quot;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;set open port only for containers (not for host)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;expose:
- &amp;quot;3000&amp;quot;  
- &amp;quot;8080&amp;quot;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mount volume&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;volumes:
- /var/log/mysql
- /home/user/mysqllog:/var/log/mysql
- ~/configs:/etc/configs/:ro
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mount all volumes to another container&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;volumes_from:
- log
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;set environment&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;environment:
- bar=foo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;set container name&lt;br /&gt;
container_name: web_app&lt;/p&gt;

&lt;h2 id=&#34;commands&#34;&gt;commands&lt;/h2&gt;

&lt;p&gt;create and boot containers&lt;br /&gt;
docker-compose up&lt;/p&gt;

&lt;p&gt;create and boot containers in background&lt;br /&gt;
docker-compose up -d&lt;/p&gt;

&lt;p&gt;stop one container&lt;br /&gt;
docker-compose stop (container name)&lt;/p&gt;

&lt;p&gt;show containers&lt;br /&gt;
docker-compose ps&lt;/p&gt;

&lt;p&gt;show logs&lt;br /&gt;
docker-compose logs&lt;/p&gt;

&lt;p&gt;implement command&lt;br /&gt;
docker-compose run (container name) /bin/bash&lt;/p&gt;

&lt;p&gt;start containers&lt;br /&gt;
docker-compose start&lt;/p&gt;

&lt;p&gt;stop containers&lt;br /&gt;
docker-compose stop&lt;/p&gt;

&lt;p&gt;force stop containers&lt;br /&gt;
docker-compose kill&lt;/p&gt;

&lt;p&gt;remove containers&lt;br /&gt;
docker-compose rm&lt;/p&gt;

&lt;h2 id=&#34;prepare-wordpress-environment&#34;&gt;prepare wordpress environment&lt;/h2&gt;

&lt;p&gt;prepare datastore container&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FROM busybox
MAINTAINER 0.1 sample@sample.com
VOLUME /var/lib/mysql
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;VOLUME means saving directory&lt;/p&gt;

&lt;p&gt;create dataonly image&lt;br /&gt;
$ docker build -t dataonly .&lt;/p&gt;

&lt;p&gt;create dataonly container and start&lt;br /&gt;
$ docker run &amp;ndash;name dataonly dataonly&lt;/p&gt;

&lt;p&gt;preapre docker-compose.yml&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;webserver:
  image: wordpress
  ports:
    - 8080:80
  links:
    - &amp;quot;dbserver:mysql&amp;quot;

dbserver:
  image: mysql
  volumes_from:
    - dataonly
  environment:
    MYSQL_ROOT_PASSWORD: password
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;boot&lt;br /&gt;
$ docker-compose up -d&lt;/p&gt;

&lt;p&gt;connect mysql&lt;br /&gt;
use another container to connect&lt;br /&gt;
$ docker run -it &amp;ndash;link (mysql container):mysql &amp;ndash;rm mysql sh -c &amp;lsquo;exec mysql -h&amp;rdquo;$MYSQL_PORT_3306_TCP_ADDR&amp;rdquo; -P&amp;rdquo;$MYSQL_PORT_3306_TCP_PORT&amp;rdquo; -uroot -p&amp;rdquo;$MYSQL_ENV_MYSQL_ROOT_PASSWORD&amp;rdquo;&amp;rsquo;&lt;/p&gt;

&lt;p&gt;or&lt;br /&gt;
$ docker exec -it wordpress_dbserver_1 sh -c &amp;lsquo;mysql -uroot -p$MYSQL_ROOT_PASSWORD&amp;rsquo;&lt;/p&gt;

&lt;p&gt;dump all databases&lt;br /&gt;
$ docker exec some-mysql sh -c &amp;lsquo;exec mysqldump &amp;ndash;all-databases -uroot -p&amp;rdquo;$MYSQL_ROOT_PASSWORD&amp;rdquo;&amp;rsquo; &amp;gt; /some/path/on/your/host/all-databases.sql&lt;/p&gt;

&lt;p&gt;dump one database (wordpress)&lt;br /&gt;
$ docker exec some-mysql sh -c &amp;lsquo;exec mysqldump wordpress -uroot -p&amp;rdquo;$MYSQL_ROOT_PASSWORD&amp;rdquo;&amp;rsquo; &amp;gt; dump.dbbackup&lt;/p&gt;

&lt;p&gt;dump tables&lt;br /&gt;
$ docker exec container_name sh -c &amp;lsquo;exec mysqldump -uroot -ppassword -t sample_database table_name&amp;rsquo; &amp;gt; table.dbbackup&lt;/p&gt;

&lt;p&gt;restore sql&lt;br /&gt;
$ docker exec -i container_name mysql sample_database -uroot -ppassword &amp;lt; dump.sql&lt;/p&gt;

&lt;h1 id=&#34;delete-docker-volumes&#34;&gt;delete docker volumes&lt;/h1&gt;

&lt;p&gt;$ docker volume rm $(docker volume ls -qf dangling=true)&lt;/p&gt;

&lt;h1 id=&#34;mysql-image&#34;&gt;mysql image&lt;/h1&gt;

&lt;p&gt;docker run command&lt;br /&gt;
$ docker run &amp;ndash;name some-mysql -e MYSQL_ROOT_PASSWORD=password -d mysql&lt;/p&gt;

&lt;h1 id=&#34;implement-rails-commands&#34;&gt;implement rails commands&lt;/h1&gt;

&lt;p&gt;$ docker-compose run (app name) rails generate scaffold Article title:string&lt;br /&gt;
$ docker-compose run (app name) rake db:migrate&lt;/p&gt;

&lt;h2 id=&#34;refferences&#34;&gt;refferences&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://hub.docker.com/_/mysql/&#34;&gt;library/mysql - Docker Hub&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>docker</title>
      <link>https://freks.jp/tips/docker/</link>
      <pubDate>Thu, 24 Nov 2016 16:39:26 +0900</pubDate>
      
      <guid>https://freks.jp/tips/docker/</guid>
      <description>

&lt;h1 id=&#34;install&#34;&gt;install&lt;/h1&gt;

&lt;p&gt;reffer to:&lt;br /&gt;
&lt;a href=&#34;https://docs.docker.com/engine/getstarted/step_one/&#34;&gt;Install Docker and run hello-world - Docker&lt;/a&gt;&lt;br /&gt;
Centos 7: &lt;a href=&#34;https://docs.docker.com/engine/installation/linux/centos/&#34;&gt;Get Docker for CentOS - Docker&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;non-root user: &lt;a href=&#34;https://docs.docker.com/engine/installation/linux/linux-postinstall/&#34;&gt;Post-installation steps for Linux - Docker&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;$ curl -fsSL &lt;a href=&#34;https://get.docker.com/&#34;&gt;https://get.docker.com/&lt;/a&gt; | sh&lt;br /&gt;
$ sudo usermod -aG docker user&lt;br /&gt;
$ sudo service docker restart&lt;/p&gt;

&lt;p&gt;logout once and login again not to need to use sudo&lt;/p&gt;

&lt;p&gt;$ curl -fsSL &lt;a href=&#34;https://get.docker.com/gpg&#34;&gt;https://get.docker.com/gpg&lt;/a&gt; | sudo apt-key add -&lt;/p&gt;

&lt;p&gt;$ docker -v&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Docker version 1.11.0, build 4dc5990
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;check docker&lt;br /&gt;
$ docker run hello-world&lt;/p&gt;

&lt;p&gt;go into inside on bash&lt;br /&gt;
$ docker run -it ubuntu bash&lt;/p&gt;

&lt;h1 id=&#34;commands&#34;&gt;commands&lt;/h1&gt;

&lt;p&gt;show downloaded docker images&lt;br /&gt;
$ docker images&lt;/p&gt;

&lt;p&gt;run ubuntu container and run a command.&lt;br /&gt;
if ubuntu isn&amp;rsquo;t downloaded, it starts downloading it.&lt;br /&gt;
docker container is booted once and stops.&lt;br /&gt;
$ docker run &amp;ndash;name sample ubuntu cat /etc/lsb-release&lt;/p&gt;

&lt;p&gt;show all containers (includes stopped one)&lt;br /&gt;
$ docker ps -a&lt;/p&gt;

&lt;p&gt;show container details&lt;br /&gt;
$ docker inspect (id)&lt;/p&gt;

&lt;p&gt;search docker images in dockerhub
$ docker search nginx&lt;/p&gt;

&lt;p&gt;remove stopped container&lt;br /&gt;
$ docker rm (id)&lt;/p&gt;

&lt;p&gt;delete all docker containers&lt;br /&gt;
$ docker rm $(docker ps -aq)&lt;/p&gt;

&lt;p&gt;remove an docker image&lt;br /&gt;
$ docker rmi (image)&lt;/p&gt;

&lt;p&gt;delete all docker images&lt;br /&gt;
$ docker rmi $(docker images -q)&lt;/p&gt;

&lt;p&gt;stop docker&lt;br /&gt;
$ docker stop (id)&lt;/p&gt;

&lt;p&gt;start a stopped container&lt;br /&gt;
$ docker start (id)&lt;/p&gt;

&lt;p&gt;run one command in a working container&lt;br /&gt;
$ docker exec (id) md5sum /etc/nginx/nginx.conf&lt;/p&gt;

&lt;p&gt;implement bash&lt;br /&gt;
$ docker exec -i -t (id) /bin/bash&lt;/p&gt;

&lt;p&gt;show docker logs&lt;br /&gt;
-t show time&lt;br /&gt;
$ docker logs -t (id)&lt;/p&gt;

&lt;p&gt;show image detail
$ docker inspect (image)&lt;/p&gt;

&lt;p&gt;attache deamon container&lt;br /&gt;
$ docker attach (id)&lt;/p&gt;

&lt;p&gt;show docker status&lt;br /&gt;
$ docker stats (id) (id) ..&lt;/p&gt;

&lt;p&gt;show container process&lt;br /&gt;
$ docker top (container id)&lt;/p&gt;

&lt;p&gt;show port transffer of container&lt;br /&gt;
$ docker port (container id)&lt;/p&gt;

&lt;p&gt;change container name&lt;br /&gt;
$ docker rename (old) (new)&lt;/p&gt;

&lt;p&gt;copy file between host and docker container&lt;br /&gt;
$ docker cp file (container id):file&lt;br /&gt;
$ docker cp (container id):file file&lt;/p&gt;

&lt;p&gt;show differences between image and container&lt;br /&gt;
$ docker diff (container id)&lt;/p&gt;

&lt;p&gt;show docker information&lt;br /&gt;
$ docker info&lt;/p&gt;

&lt;p&gt;create images from container&lt;br /&gt;
$ docker commit (container id) (image name:tag name)&lt;/p&gt;

&lt;p&gt;export container&lt;br /&gt;
export and import is pair&lt;br /&gt;
this tar file includes directory hierarchy&lt;br /&gt;
$ docker export container &amp;gt; (file.tar)&lt;/p&gt;

&lt;p&gt;import image from exported container tar file&lt;br /&gt;
$ docker import (file) (image name:tag name)&lt;/p&gt;

&lt;p&gt;save docker image to tar&lt;br /&gt;
save and load is pair&lt;br /&gt;
save as layer&lt;br /&gt;
$ docker save -o (file) (image name)&lt;/p&gt;

&lt;p&gt;load saved docker image file&lt;br /&gt;
$ docker load -i (file)&lt;/p&gt;

&lt;p&gt;verify network&lt;br /&gt;
inspect command can show the network of the container&lt;br /&gt;
$ docker network ls&lt;/p&gt;

&lt;p&gt;let the container join the specified network&lt;br /&gt;
$ docker run -d &amp;ndash;net=my-bridge-network &amp;ndash;name db training/postgres&lt;/p&gt;

&lt;p&gt;change the network&lt;br /&gt;
$ docker network connect my-bridge-network web&lt;/p&gt;

&lt;p&gt;show container volumes&lt;br /&gt;
$ docker volume ls&lt;/p&gt;

&lt;p&gt;show container dangling volumes&lt;br /&gt;
this is remained when to delete containers with volume container&lt;br /&gt;
$ docker volume ls -qf dangling=true&lt;/p&gt;

&lt;p&gt;clean up dangling volumes&lt;br /&gt;
$ docker volume rm $(docker volume ls -qf dangling=true)&lt;/p&gt;

&lt;p&gt;back up and restore data&lt;br /&gt;
$ docker run &amp;ndash;rm &amp;ndash;volumes-from dbstore -v $(pwd):/backup ubuntu tar cvf /backup/backup.tar /dbdata&lt;br /&gt;
$ docker run &amp;ndash;rm &amp;ndash;volumes-from dbstore2 -v $(pwd):/backup ubuntu bash -c &amp;ldquo;cd /dbdata &amp;amp;&amp;amp; tar xvf /backup/backup.tar &amp;ndash;strip 1&amp;rdquo;&lt;/p&gt;

&lt;h1 id=&#34;docker-run-parameters&#34;&gt;docker run parameters&lt;/h1&gt;

&lt;p&gt;-d -&amp;gt; deamon&lt;br /&gt;
-P -&amp;gt; connect port between the host and the container&lt;br /&gt;
&amp;ndash;name -&amp;gt; container name&lt;br /&gt;
-e -&amp;gt; set env&lt;br /&gt;
-v -&amp;gt; bind directory&lt;br /&gt;
$ docker run -d -P &amp;ndash;name=server -e myenv=foo -v ~/:/usr/share/local/nginx/html nginx&lt;/p&gt;

&lt;p&gt;bind ports&lt;br /&gt;
-p 60000-60030:60000-60030 -p 8080:80&lt;/p&gt;

&lt;p&gt;&amp;ndash;link (id):(alias)&lt;br /&gt;
you can set alias by yourself&lt;br /&gt;
$ docker run &amp;ndash;link (id):(alias) ubuntu&lt;/p&gt;

&lt;p&gt;$ docker run &amp;ndash;link server:ngx ubuntu env | grep -i _port&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NGX_PORT=tcp://172.17.0.2:80
NGX_PORT_80_TCP=tcp://172.17.0.2:80
NGX_PORT_80_TCP_ADDR=172.17.0.2
NGX_PORT_80_TCP_PORT=80
NGX_PORT_80_TCP_PROTO=tcp
NGX_PORT_443_TCP=tcp://172.17.0.2:443
NGX_PORT_443_TCP_ADDR=172.17.0.2
NGX_PORT_443_TCP_PORT=443
NGX_PORT_443_TCP_PROTO=tcp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;ndash;rm automatically remove the container if it exists&lt;br /&gt;
$ docker run &amp;ndash;rm &amp;ndash;link server:ngx ubuntu cat /etc/hosts&lt;/p&gt;

&lt;h1 id=&#34;prepare-dockerfile-and-run&#34;&gt;prepare Dockerfile and run&lt;/h1&gt;

&lt;p&gt;$ vim Dockerfile&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FROM centos:7
MAINTAINER sample taro &amp;lt;taro@sample.co.jp&amp;gt;
RUN yum -y install epel-release
RUN yum -y install httpd
EXPOSE 80 443
CMD [&amp;quot;/usr/sbin/httpd&amp;quot;, &amp;quot;-DFOREGROUND&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;$ docker build -t (image name:tag name) .&lt;/p&gt;

&lt;h1 id=&#34;dockerfile&#34;&gt;Dockerfile&lt;/h1&gt;

&lt;p&gt;RUN&lt;br /&gt;
this is used to create docker image&lt;/p&gt;

&lt;p&gt;shell type&lt;br /&gt;
implement on /bin/sh&lt;br /&gt;
RUN echo こんにちは&lt;/p&gt;

&lt;p&gt;exec type&lt;br /&gt;
this doesn&amp;rsquo;t use /bin/sh&lt;br /&gt;
RUN [&amp;ldquo;echo, &amp;ldquo;こんにちは&amp;rdquo;]&lt;/p&gt;

&lt;p&gt;exec type&lt;br /&gt;
RUN [&amp;ldquo;/bin/bash&amp;rdquo;, &amp;ldquo;-c&amp;rdquo;, &amp;ldquo;echo &amp;lsquo;こんにちは&amp;rsquo;&amp;rdquo;]&lt;/p&gt;

&lt;p&gt;CMD&lt;br /&gt;
implement command&lt;br /&gt;
this can be overwritted docker run parameters&lt;/p&gt;

&lt;p&gt;start deamon using shell type&lt;br /&gt;
CMD /usr/sbin/httpd -D FOREGROUND&lt;/p&gt;

&lt;p&gt;start deamon using exec type&lt;br /&gt;
CMD [&amp;ldquo;/usr/sbin/httpd&amp;rdquo;,&amp;ldquo;-D&amp;rdquo;,&amp;ldquo;FOREGROUND&amp;rdquo;]&lt;/p&gt;

&lt;p&gt;ENTRY POINT&lt;br /&gt;
implement command&lt;br /&gt;
this can&amp;rsquo;t be overwritted docker run parameters&lt;br /&gt;
e.g. $ docker run -d -p 81:80 sample /usr/sbin/nginx -g &amp;ldquo;daemon off;&amp;rdquo;&lt;/p&gt;

&lt;p&gt;start deamon using ENTRYPOINT shell type&lt;br /&gt;
ENTRYPOINT /usr/sbin/httpd -D FOREGROUND&lt;/p&gt;

&lt;p&gt;start deamon using ENTRYPOINT exec type&lt;br /&gt;
ENTRYPOINT [&amp;ldquo;/usr/sbin/httpd&amp;rdquo;,&amp;ldquo;-D&amp;rdquo;,&amp;ldquo;FOREGROUND&amp;rdquo;]&lt;/p&gt;

&lt;p&gt;place web files when building&lt;br /&gt;
this create new images&lt;br /&gt;
ONBUILD website.tar /var/www/html/&lt;/p&gt;

&lt;p&gt;set environment parameter&lt;br /&gt;
ENV myName &amp;ldquo;taro&amp;rdquo;&lt;/p&gt;

&lt;p&gt;set working directory&lt;br /&gt;
equals to cd sample&lt;br /&gt;
WORKDIR sample&lt;/p&gt;

&lt;p&gt;assign implement user&lt;br /&gt;
USER sample&lt;/p&gt;

&lt;p&gt;set label&lt;br /&gt;
SET samplelabel&lt;/p&gt;

&lt;p&gt;expose port&lt;br /&gt;
EXPOSE 8080&lt;/p&gt;

&lt;p&gt;add file or directory&lt;br /&gt;
this can add tar file, then automatically untar&lt;br /&gt;
ADD index.html /var/www/html/&lt;br /&gt;
ADD sample.tar /var/www/html/&lt;br /&gt;
ADD &lt;a href=&#34;http://sample.com/index.html&#34;&gt;http://sample.com/index.html&lt;/a&gt; /var/www/html/&lt;/p&gt;

&lt;p&gt;copy file or directory&lt;br /&gt;
COPY index.html /var/www/html/&lt;/p&gt;

&lt;p&gt;docker-build sends all files in same directory,&lt;br /&gt;
so prepare .dockerignore file&lt;/p&gt;

&lt;p&gt;mount volume&lt;br /&gt;
MOUNT /var/log/httpd&lt;/p&gt;

&lt;h1 id=&#34;prepare-private-repository-and-push&#34;&gt;prepare private repository and push&lt;/h1&gt;

&lt;p&gt;use registory image&lt;br /&gt;
tag 2.0 is created by go-lang&lt;br /&gt;
docker pull registory:2.0&lt;/p&gt;

&lt;p&gt;run repository&lt;br /&gt;
if this container is stopped, registered image is gone&lt;br /&gt;
this needs to mount or something&lt;br /&gt;
docker run -d -p 5000:5000 registry:2.0&lt;/p&gt;

&lt;p&gt;name ruled image name&lt;br /&gt;
docker tag (local image) localhost:5000/(image name)&lt;/p&gt;

&lt;p&gt;push image&lt;br /&gt;
docker push localhost:5000/(image name)&lt;/p&gt;

&lt;p&gt;pull image&lt;br /&gt;
docker pull localhost:5000/(image name)&lt;/p&gt;

&lt;h1 id=&#34;push-to-hub-docker&#34;&gt;push to hub.docker&lt;/h1&gt;

&lt;p&gt;create account on &lt;a href=&#34;https://hub.docker.com/&#34;&gt;https://hub.docker.com/&lt;/a&gt;&lt;br /&gt;
$ docker tag docker-whale shojik/docker-whale:latest&lt;br /&gt;
$ docker login &amp;ndash;username=shojik &amp;ndash;email=sample@sample.com&lt;/p&gt;

&lt;p&gt;save token to ~/.docker/config.json&lt;/p&gt;

&lt;p&gt;$ docker push shojik/docker-whale&lt;/p&gt;

&lt;h2 id=&#34;implement-composer-install&#34;&gt;implement composer install&lt;/h2&gt;

&lt;p&gt;use &lt;a href=&#34;https://hub.docker.com/_/composer/&#34;&gt;composer - Docker Hub&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;docker pull composer&lt;br /&gt;
move the directory include composer.json&lt;br /&gt;
$ docker run &amp;ndash;rm -v $(pwd):/app composer install&lt;/p&gt;

&lt;h1 id=&#34;backup-mysql-data-container&#34;&gt;backup mysql data container&lt;/h1&gt;

&lt;p&gt;backup&lt;br /&gt;
$ docker run &amp;ndash;rm &amp;ndash;volumes-from dataonly -v $(pwd):/backup dataonly tar cvf /backup/backup.tar /var/lib/mysql&lt;/p&gt;

&lt;p&gt;restore&lt;br /&gt;
$ docker run &amp;ndash;rm &amp;ndash;volumes-from dataonly -v $(pwd):/backup dataonly sh -c &amp;ldquo;cd /var/lib/ &amp;amp;&amp;amp; tar -xvf /backup/backup.tar&amp;rdquo;&lt;/p&gt;

&lt;h2 id=&#34;security-check&#34;&gt;security check&lt;/h2&gt;

&lt;p&gt;see &lt;a href=&#34;https://github.com/docker/docker-bench-security&#34;&gt;docker/docker-bench-security: The Docker Bench for Security is a script that checks for dozens of common best-practices around deploying Docker containers in production.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;コマンド実行すると、判定してくれる&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker run -it --net host --pid host --cap-add audit_control \
    -e DOCKER_CONTENT_TRUST=$DOCKER_CONTENT_TRUST \
    -v /var/lib:/var/lib \
    -v /var/run/docker.sock:/var/run/docker.sock \
    -v /usr/lib/systemd:/usr/lib/systemd \
    -v /etc:/etc --label docker_bench_security \
    docker/docker-bench-security
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;logging&#34;&gt;logging&lt;/h2&gt;

&lt;p&gt;show application logs to use &lt;code&gt;docker logs&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ln -sf /dev/stdout /var/log/nginx/access.log
ln -sf /dev/stderr /var/log/nginx/error.log
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;refferences&#34;&gt;refferences&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/zembutsu/items/d146295cfcf69c205c1e&#34;&gt;Dockerのライフサイクルを理解するハンズオン資料 - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/kohey18/items/dffe9b11d330576ab852&#34;&gt;実例で学ぶDockerハンズオン - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://amzn.to/2dNjPdn&#34;&gt;プログラマのためのDocker教科書 インフラの基礎知識＆コードによる環境構築の自動化&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>